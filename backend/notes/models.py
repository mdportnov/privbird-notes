from __future__ import annotations

import secrets

from django.contrib.auth.hashers import check_password, make_password
from django.db import models

from notes.exceptions.InvalidPassword import InvalidPasswordException
from notes.exceptions.NoteNotFound import NoteNotFoundException
from notes.exceptions.PasswordRequired import PasswordRequiredException
from notes.utils.Constants import Constants
from notes.utils.crypto import decrypt, encrypt
from notes.utils.slug import generate_slug


class Note(models.Model):
    class Network(models.TextChoices):
        HTTPS = 'HTTPS'
        TOR = 'TOR'
        I2P = 'I2P'

    class Language(models.TextChoices):
        RU = 'RU'
        EN = 'EN'

    # Real content
    real_content = models.TextField(max_length=Constants.MAX_CONTENT_LENGTH, null=True)
    real_password = models.CharField(max_length=Constants.MAX_PASSWORD_LENGTH, default=None, null=True)
    real_notification = models.BooleanField(default=False)

    # Fake content
    fake_content = models.TextField(max_length=Constants.MAX_CONTENT_LENGTH, default=None, null=True)
    fake_password = models.TextField(max_length=Constants.MAX_PASSWORD_LENGTH, default=None, null=True)
    fake_notification = models.BooleanField(default=None, null=True)

    # Options
    network = models.CharField(max_length=5, choices=Network.choices, default=Network.HTTPS)
    language = models.CharField(max_length=2, choices=Language.choices, default=Language.EN)
    expires = models.DateTimeField()
    email = models.EmailField(default=None, null=True)

    # Autogenerated
    salt = models.CharField(max_length=Constants.SALT_LENGTH, default=None, null=True)
    slug = models.SlugField(max_length=Constants.SLUG_LENGTH, unique=True)

    @staticmethod
    def __find_by_slug(slug: str) -> Note:
        """
        Find Note entity by slug
        """
        if not Note.objects.filter(slug=slug).exists():
            raise NoteNotFoundException()
        return Note.objects.get(slug=slug)

    @staticmethod
    def read_content_by_slug(slug: str) -> str:
        """
        Read Note content, when real_password and fake_password are both None
        """
        note = Note.__find_by_slug(slug)
        if note.real_password is not None or note.fake_password is not None:
            raise PasswordRequiredException()
        return note.__get_raw_content()

    @staticmethod
    def read_content_by_slug_and_password(slug: str, password: str) -> str:
        """
        Read Note content, when real_password or fake_password are not None
        """
        note = Note.__find_by_slug(slug)
        return note.__decrypt(password)

    def save(self, force_insert=False, force_update=False, using=None, update_fields=None):
        """
        Generate autogenerated values, encrypt content and save Note entity
        """
        if self._state.adding is True:
            self.__generate_values()
            self.__encrypt_note_data()
            self.__encrypt_fake_data()
        super(Note, self).save(force_insert, force_update, using, update_fields)

    def __generate_values(self):
        """
        Generate auto generated Note values before save
        """
        self.slug = generate_slug()
        if self.real_password or self.fake_password:
            self.salt = secrets.token_hex()[:Constants.SALT_LENGTH]

    def __encrypt_note_data(self):
        """
        Encrypt real Note content before save
        """
        if self.real_password is not None:
            self.real_content = encrypt(self.real_password, self.salt, self.real_content)
            self.real_password = make_password(self.real_password, self.salt, 'pbkdf2_sha256')

    def __encrypt_fake_data(self):
        """
        Encrypt fake Note content before save
        """
        if self.fake_password is not None:
            self.fake_content = encrypt(self.fake_password, self.salt, self.fake_content)
            self.fake_password = make_password(self.fake_password, self.salt, 'pbkdf2_sha256')

    def __get_raw_content(self) -> str:
        """
        Get Note content without decryption and destroy Note when needed
        """
        is_real = self.real_content is not None
        content = self.__get_content(is_real)
        is_destroyed = self.real_content is None and self.fake_content is None
        if is_destroyed:
            self.delete()
        self.__notify_if_needed(is_real=is_real, is_destroyed=is_destroyed)
        return content

    def __get_content_same_passwords(self) -> str:
        """
        Get Note content when real and fake passwords are equal and destroy Note when needed
        """
        return self.__get_raw_content()

    def __get_content_different_passwords(self, is_real: bool) -> str:
        """
        Get Note content when real and fake passwords are not equal abd destroy Note
        """
        content = self.__get_content(is_real)
        self.delete()
        self.__notify_if_needed(is_real=is_real, is_destroyed=True)
        return content

    def __get_content(self, is_real: bool) -> str:
        """
        Get Note content and make content None
        """
        content = self.real_content if is_real else self.fake_content
        if is_real:
            self.real_password = None
            self.real_content = None
        else:
            self.fake_password = None
            self.fake_content = None
        self.save()
        return content

    def __get_encrypted_content(self, password: str) -> str:
        """
        Get encrypted Note content and destroy Note if password differs or fake content was read
        """
        real = self.real_password and check_password(password, self.real_password)
        fake = self.fake_password and check_password(password, self.fake_password)
        if real and fake:
            return self.__get_content_same_passwords()
        elif real or fake:
            return self.__get_content_different_passwords(is_real=real)
        raise InvalidPasswordException()

    def __decrypt(self, password: str) -> str:
        """
        Decrypt Note content and destroy Note if password differs or fake content was read
        """
        content = self.__get_encrypted_content(password)
        return decrypt(password, self.salt, content)

    def __notify_if_needed(self, is_real: bool, is_destroyed: bool):
        """
        Send email notification if needed
        """
        from notes.tasks import notify
        if is_real and self.real_notification or not is_real and self.fake_notification:
            notify(self, is_real, is_destroyed)

    def __str__(self) -> str:
        return f'Note {self.slug}'
