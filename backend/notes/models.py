from __future__ import annotations

import secrets

from django.contrib.auth.hashers import check_password, make_password
from django.db import models

from notes.exceptions.InvalidPassword import InvalidPasswordException
from notes.exceptions.NoteNotFound import NoteNotFoundException
from notes.exceptions.PasswordRequired import PasswordRequiredException
from notes.utils.Constants import Constants
from notes.utils.Expires import Expires
from notes.utils.crypto import decrypt, encrypt
from notes.utils.slug import generate_slug


class Note(models.Model):
    class Network(models.TextChoices):
        HTTPS = 'HTTPS'
        TOR = 'TOR'
        I2P = 'I2P'

    class Language(models.TextChoices):
        RU = 'RU'
        EN = 'EN'

    # Real content
    real_content = models.TextField(max_length=Constants.MAX_CONTENT_LENGTH, null=True)
    real_password = models.CharField(max_length=Constants.MAX_PASSWORD_LENGTH, default=None, null=True)
    real_notification = models.BooleanField(default=False)

    # Fake content
    fake_content = models.TextField(max_length=Constants.MAX_CONTENT_LENGTH, default=None, null=True)
    fake_password = models.TextField(max_length=Constants.MAX_PASSWORD_LENGTH, default=None, null=True)
    fake_notification = models.BooleanField(default=None, null=True)

    # Options
    network = models.CharField(max_length=5, choices=Network.choices, default=Network.HTTPS)
    language = models.CharField(max_length=2, choices=Language.choices, default=Language.EN)
    expires = models.DateTimeField()
    email = models.EmailField(default=None, null=True)

    # Autogenerated
    salt = models.CharField(max_length=Constants.SALT_LENGTH, default=None, null=True)
    slug = models.SlugField(max_length=Constants.SLUG_LENGTH, unique=True)

    @staticmethod
    def __find_by_slug(slug: str) -> Note:
        if not Note.objects.filter(slug=slug).exists():
            raise NoteNotFoundException()
        return Note.objects.get(slug=slug)

    @staticmethod
    def find_by_slug(slug: str) -> str:
        note = Note.__find_by_slug(slug)
        if note.real_password is not None:
            raise PasswordRequiredException()
        content = note.get_content()
        return content

    @staticmethod
    def find_by_slug_and_password(slug: str, password: str) -> str:
        note = Note.__find_by_slug(slug)
        if note.real_password is None or not check_password(password, note.real_password):
            raise InvalidPasswordException()
        content = note.get_content()
        return decrypt(password, note.salt, content)

    def check_password_match(self):
        if self.fake_password != self.real_password:
            self.fake_password = None
            self.fake_content = None

    def generate_values(self):
        self.slug = generate_slug()
        if self.real_password is not None:
            self.salt = secrets.token_hex()[:Constants.SALT_LENGTH]

    def encrypt_note_data(self):
        if self.real_password is not None:
            self.real_content = encrypt(self.real_password, self.salt, self.real_content)
            self.real_password = make_password(self.real_password, self.salt, 'pbkdf2_sha256')

    def encrypt_fake_data(self):
        if self.fake_password is not None:
            self.fake_content = encrypt(self.fake_password, self.salt, self.fake_content)
            self.fake_password = make_password(self.fake_password, self.salt, 'pbkdf2_sha256')

    def save(self, force_insert=False, force_update=False, using=None, update_fields=None):
        if self._state.adding is True:
            self.check_password_match()
            self.generate_values()
            self.encrypt_note_data()
            self.encrypt_fake_data()
        super(Note, self).save(force_insert, force_update, using, update_fields)

    def notify_if_needed(self, is_real: bool):
        from notes.tasks import notify
        if is_real and self.real_notification or not is_real and self.fake_notification:
            notify(self, is_real)

    def get_content(self) -> str:
        result = self.real_content if self.real_content else self.fake_content
        if self.real_content is not None:
            self.notify_if_needed(is_real=True)
            self.real_content = None
            self.save() if self.fake_content else self.delete()
        elif self.fake_content is not None:
            self.notify_if_needed(is_real=False)
            self.fake_content = None
            self.delete()
        return result
